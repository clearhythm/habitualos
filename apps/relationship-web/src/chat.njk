---
title: Chat - Pidgerton
layout: base.njk
permalink: /chat/
---

<style>
  /* Full-height chat layout - only for this page */
  body {
    overflow: hidden; /* Prevent body scroll */
  }

  footer {
    display: none !important; /* Hide footer on chat page */
  }

  body > nav {
    background: transparent !important;
  }

  #chat-page-container {
    overflow: hidden;
  }

  #message-input::placeholder {
    color: #6d28d9;
  }

  #message-input {
    color: #1e0a3c;
  }

  .moment-badge {
    display: inline-block;
    padding: 0.15rem 0.5rem;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.03em;
  }
  .moment-badge-happy { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
  .moment-badge-sad { background: rgba(96, 165, 250, 0.2); color: #60a5fa; }
  .moment-badge-hard { background: rgba(251, 146, 60, 0.2); color: #fb923c; }
</style>

<!-- Chat Container -->
<div id="chat-page-container" style="position: fixed; top: 60px; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column;">
  <div id="chat-container" style="display: flex; flex-direction: column; height: 100%;">
    <!-- Messages (scrollable area) - scrollbar at viewport edge -->
    <div id="chat-messages" class="chat-messages" style="flex: 1; min-height: 0; overflow-y: auto; width: 100%;">
      <div id="chat-messages-inner" style="max-width: 700px; margin: 0 auto; padding: 1.5rem; display: flex; flex-direction: column; gap: 1rem;"></div>
    </div>

    <!-- Input area (fixed at bottom) -->
    <div style="flex-shrink: 0; flex-grow: 0; padding: 1rem 1.5rem; display: flex; justify-content: center;">
      <div style="width: 100%; max-width: 700px;">
      <form id="chat-form">
        <div style="position: relative;">
          <textarea
            name="message"
            id="message-input"
            placeholder="Reply..."
            required
            rows="4"
            style="width: 100%; padding: 0.75rem 3rem 0.75rem 0.75rem; border: 1px solid rgba(255,255,255,0.3); border-radius: 12px; font-size: 1rem; font-family: inherit; resize: none; max-height: 150px; overflow-y: auto; box-sizing: border-box; background: rgba(255,255,255,.60);"
          ></textarea>
          <button
            type="submit"
            id="send-button"
            disabled
            style="position: absolute; right: 0.5rem; bottom: 0.5rem; width: 32px; height: 32px; background: rgba(255,255,255,0.2); color: rgba(255,255,255,0.4); border: none; border-radius: 50%; cursor: not-allowed; transition: all 0.2s; display: flex; align-items: center; justify-content: center; padding: 0;"
          >
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256">
              <path d="M208.49,120.49a12,12,0,0,1-17,0L140,69V216a12,12,0,0,1-24,0V69L64.49,120.49a12,12,0,0,1-17-17l72-72a12,12,0,0,1,17,0l72,72A12,12,0,0,1,208.49,120.49Z"></path>
            </svg>
          </button>
        </div>
      </form>

      <!-- Actions below input -->
      <div style="display: flex; justify-content: center; gap: 1.5rem; padding-top: 0.75rem;">
        <button
          id="save-chat-btn"
          type="button"
          style="background: none; border: none; color: rgba(255,255,255,0.7); font-size: 0.85rem; cursor: pointer; padding: 0.25rem 0.5rem; transition: color 0.2s;"
          onmouseover="this.style.color='white'"
          onmouseout="this.style.color='rgba(255,255,255,0.7)'"
          title="Save conversation"
        >
          Save
        </button>
        <button
          id="history-chat-btn"
          type="button"
          style="background: none; border: none; color: rgba(255,255,255,0.5); font-size: 0.85rem; cursor: pointer; padding: 0.25rem 0.5rem; transition: color 0.2s;"
          onmouseover="this.style.color='rgba(255,255,255,0.7)'"
          onmouseout="this.style.color='rgba(255,255,255,0.5)'"
          title="View saved conversations"
        >
          History
        </button>
        <button
          id="reset-chat-btn"
          type="button"
          style="background: none; border: none; color: rgba(255,255,255,0.5); font-size: 0.85rem; cursor: pointer; padding: 0.25rem 0.5rem; transition: color 0.2s;"
          onmouseover="this.style.color='rgba(255,255,255,0.7)'"
          onmouseout="this.style.color='rgba(255,255,255,0.5)'"
          title="Start over"
        >
          Reset
        </button>
      </div>
      </div>
    </div>
  </div>
</div>

<!-- "Ready to Capture?" Modal Overlay -->
<div id="capture-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 1000; align-items: center; justify-content: center;">
  <div style="background: white; padding: 2.5rem 2rem; border-radius: 12px; text-align: center; max-width: 420px; margin: 0 1rem; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
    <div style="font-size: 2rem; margin-bottom: 1rem;">üëí</div>
    <h3 id="capture-modal-title" style="margin: 0 0 0.75rem 0; font-size: 1.25rem; color: #1e0a3c;">Ready to capture this?</h3>
    <p id="capture-modal-summary" style="margin: 0 0 1.5rem 0; font-size: 0.95rem; color: #666; line-height: 1.5; text-align: left;"></p>
    <button
      id="capture-confirm-btn"
      style="padding: 0.75rem 2rem; background: #7c3aed; color: white; border: none; border-radius: 24px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);"
    >
      Capture
    </button>
    <button
      id="capture-dismiss-btn"
      style="display: block; margin: 1.25rem auto 0; padding: 0.5rem 1rem; background: transparent; color: #999; border: none; font-size: 0.9rem; cursor: pointer; text-decoration: underline;"
    >
      No, keep talking
    </button>
  </div>
</div>

<!-- Survey Check-in Modal Overlay -->
<div id="survey-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0, 0, 0, 0.5); z-index: 1000; align-items: center; justify-content: center;">
  <div style="background: white; padding: 2.5rem 2rem; border-radius: 12px; text-align: center; max-width: 420px; margin: 0 1rem; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);">
    <div style="font-size: 3.5rem;">ü¶•</div>
    <h3 style="margin: 0; font-size: 1.25rem; color: #1e0a3c;">Save your replies?</h3>
    <p style="margin: 0 0 1.5rem 0; font-size: 0.9rem; color: #666;">Here's what we'll save for you.</p>
    <div id="survey-modal-scores" style="margin: 0 0 1.5rem 0; text-align: left;"></div>
    <button
      id="survey-confirm-btn"
      style="padding: 0.75rem 2rem; background: #7c3aed; color: white; border: none; border-radius: 24px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);"
    >
      Save
    </button>
    <button
      id="survey-dismiss-btn"
      style="display: block; margin: 1.25rem auto 0; padding: 0.5rem 1rem; background: transparent; color: #999; border: none; font-size: 0.9rem; cursor: pointer; text-decoration: underline;"
    >
      Keep chatting
    </button>
  </div>
</div>

<script type="module">
  import { isSignedIn, getUserId, getFirstName } from '/assets/js/auth/auth.js';
  import { showToast } from '/assets/js/components/chat-toast.js';

  if (!isSignedIn()) { location.href = '/signin/'; throw new Error('redirecting'); }
  const userId = getUserId();
  const userName = getFirstName();

  // Reply mode detection
  const urlParams = new URLSearchParams(window.location.search);
  const replyToMomentId = urlParams.get('replyTo');
  let replyMoment = null;

  const chatMessages = document.getElementById('chat-messages-inner');
  const chatMessagesContainer = document.getElementById('chat-messages');
  const chatForm = document.getElementById('chat-form');
  const messageInput = document.getElementById('message-input');
  const sendButton = document.getElementById('send-button');

  let loadingMessageElement = null;

  // Inject animations
  (() => {
    const style = document.createElement('style');
    style.id = 'streaming-cursor-style';
    style.textContent = '@keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }';
    document.head.appendChild(style);
  })();
  let thinkingTimer = null;
  let thinkingInterval = null;
  let thinkingTimeout = null;

  const thinkingWords = ['Thinking', 'Considering', 'Reflecting', 'Pondering'];

  function startThinkingCycle(span, startIndex) {
    let wordIndex = startIndex || 0;
    function typeWord() {
      const word = thinkingWords[wordIndex % thinkingWords.length] + '...';
      let charIndex = 0;
      span.textContent = '\u00a0';
      thinkingInterval = setInterval(() => {
        charIndex++;
        span.textContent = word.slice(0, charIndex);
        if (charIndex >= word.length) {
          clearInterval(thinkingInterval);
          thinkingInterval = null;
          wordIndex++;
          thinkingTimeout = setTimeout(typeWord, 5000);
        }
      }, 60);
    }
    typeWord();
  }

  function stopThinkingCycle() {
    clearTimeout(thinkingTimer);
    clearInterval(thinkingInterval);
    clearTimeout(thinkingTimeout);
    thinkingInterval = null;
    thinkingTimeout = null;
  }

  // Capture modal elements
  const captureModal = document.getElementById('capture-modal');
  const captureModalSummary = document.getElementById('capture-modal-summary');
  const captureConfirmBtn = document.getElementById('capture-confirm-btn');
  const captureDismissBtn = document.getElementById('capture-dismiss-btn');
  let pendingSignal = null;

  // Survey modal elements
  const surveyModal = document.getElementById('survey-modal');
  const surveyModalScores = document.getElementById('survey-modal-scores');
  const surveyConfirmBtn = document.getElementById('survey-confirm-btn');
  const surveyDismissBtn = document.getElementById('survey-dismiss-btn');

  // Streaming state
  let streamingMessageElement = null;
  let streamingText = '';
  let streamingStarted = false;

  // Relly theme color
  const THEME_COLOR = '#7c3aed'; // Purple
  const THEME_COLOR_DARK = '#4c1d95'; // Deep purple

  // Local storage keys for relational chat (reply mode uses separate keys)
  const REPLY_SUFFIX = replyToMomentId ? '_reply' : '';
  const RELATIONAL_CHAT_HISTORY_KEY = 'relational_chat_history' + REPLY_SUFFIX;
  const RELATIONAL_CHAT_ID_KEY = 'relational_chat_id' + REPLY_SUFFIX;
  const RELATIONAL_LAST_SAVED_INDEX_KEY = 'relational_last_saved_index' + REPLY_SUFFIX;

  function saveChatHistory(history) {
    localStorage.setItem(RELATIONAL_CHAT_HISTORY_KEY, JSON.stringify(history));
  }

  function getChatHistory() {
    const stored = localStorage.getItem(RELATIONAL_CHAT_HISTORY_KEY);
    return stored ? JSON.parse(stored) : [];
  }

  function clearChatHistory() {
    localStorage.removeItem(RELATIONAL_CHAT_HISTORY_KEY);
    localStorage.removeItem(RELATIONAL_CHAT_ID_KEY);
    localStorage.removeItem(RELATIONAL_LAST_SAVED_INDEX_KEY);
  }

  function saveChatId(id) {
    localStorage.setItem(RELATIONAL_CHAT_ID_KEY, id);
  }

  function getChatId() {
    return localStorage.getItem(RELATIONAL_CHAT_ID_KEY);
  }

  function saveLastSavedIndex(index) {
    localStorage.setItem(RELATIONAL_LAST_SAVED_INDEX_KEY, index.toString());
  }

  function getLastSavedIndex() {
    const stored = localStorage.getItem(RELATIONAL_LAST_SAVED_INDEX_KEY);
    return stored ? parseInt(stored, 10) : 0;
  }

  // Update send button state based on textarea content
  function updateSendButton() {
    const hasContent = messageInput.value.trim().length > 0;
    sendButton.disabled = !hasContent;

    if (hasContent) {
      sendButton.style.background = 'white';
      sendButton.style.color = THEME_COLOR;
      sendButton.style.cursor = 'pointer';
    } else {
      sendButton.style.background = 'rgba(255,255,255,0.2)';
      sendButton.style.color = 'rgba(255,255,255,0.4)';
      sendButton.style.cursor = 'not-allowed';
    }
  }

  // Show loading message inline
  function showLoadingMessage() {
    const loadingDiv = document.createElement('div');
    loadingDiv.style.cssText = 'padding: 0.875rem 1rem 1rem 1rem; border-radius: 8px; max-width: 80%; word-wrap: break-word; line-height: 1.5; background-color: rgba(255,255,255,0.12); color: rgba(255,255,255,0.9); align-self: flex-start; border-left: 3px solid #4c1d95; border-bottom-left-radius: 4px;';
    loadingDiv.innerHTML = '<span style="color: rgba(255,255,255,0.5); font-style: italic;">Listening...</span>';
    chatMessages.appendChild(loadingDiv);
    chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
    loadingMessageElement = loadingDiv;
  }

  // Hide loading message
  function hideLoadingMessage() {
    if (loadingMessageElement) {
      loadingMessageElement.remove();
      loadingMessageElement = null;
    }
  }

  // Streaming message helpers
  function showStreamingMessage() {
    streamingText = '';
    streamingStarted = false;
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = 'padding: 0.875rem 1rem 1rem 1rem; border-radius: 8px; max-width: 80%; word-wrap: break-word; line-height: 1.5; background-color: rgba(255,255,255,0.12); color: rgba(255,255,255,0.9); align-self: flex-start; border-left: 3px solid #4c1d95; border-bottom-left-radius: 4px;';
    messageDiv.innerHTML = '<span class="thinking-label" style="color: rgba(255,255,255,0.5); font-style: italic;">Thinking...</span>';
    chatMessages.appendChild(messageDiv);
    chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
    streamingMessageElement = messageDiv;

    // After 3s of no tokens, start cycling words
    stopThinkingCycle();
    thinkingTimer = setTimeout(() => {
      const label = messageDiv.querySelector('.thinking-label');
      if (label && !streamingStarted) {
        startThinkingCycle(label, 1);
      }
    }, 3000);
  }

  function appendStreamingText(text) {
    if (!streamingMessageElement) return;
    streamingText += text;

    // On first token, switch from "Thinking..." to streaming mode
    if (!streamingStarted) {
      streamingStarted = true;
      stopThinkingCycle();
      streamingMessageElement.style.borderLeftColor = '#4c1d95';
    }

    // Filter out signal text ‚Äî don't render anything from signals onward
    let displayText = streamingText;
    const signalMarkers = ['SAVE_MOMENT', 'STORE_MEASUREMENT', 'SEND_REPLY'];
    for (const marker of signalMarkers) {
      const idx = displayText.indexOf(marker);
      if (idx !== -1) {
        displayText = displayText.substring(0, idx).trim();
        break;
      }
    }
    if (displayText !== streamingText && !displayText) {
      streamingMessageElement.innerHTML = '<span class="thinking-label" style="color: rgba(255,255,255,0.5); font-style: italic;">Thinking...</span>';
      return;
    }

    // Update content with cursor at end
    if (window.marked) {
      streamingMessageElement.innerHTML = marked.parse(displayText) + `<span class="streaming-cursor" style="display: inline-block; width: 2px; height: 1em; background: rgba(255,255,255,0.6); animation: blink 1s infinite;"></span>`;
    } else {
      streamingMessageElement.textContent = displayText;
    }
    chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
  }

  function finalizeStreamingMessage(signal = null) {
    if (!streamingMessageElement) return { text: '', displayText: '', signal: null };

    // Remove cursor and finalize content
    const cursor = streamingMessageElement.querySelector('.streaming-cursor');
    if (cursor) cursor.remove();

    // Strip signal text from display and stored content
    let displayText = streamingText;
    const signalMarkers = ['SAVE_MOMENT', 'STORE_MEASUREMENT', 'SEND_REPLY'];
    for (const marker of signalMarkers) {
      const idx = displayText.indexOf(marker);
      if (idx !== -1) {
        displayText = displayText.substring(0, idx).trim();
        break;
      }
    }
    if (!displayText && signal) {
      if (signal.type === 'STORE_MEASUREMENT') {
        displayText = "Here are your check-in results.";
      } else if (signal.type === 'SEND_REPLY') {
        displayText = "Sending your reply now.";
      } else {
        displayText = "Looks like we're ready to capture this.";
      }
    }

    // Re-render with final markdown (signal-stripped)
    if (window.marked && displayText) {
      streamingMessageElement.innerHTML = marked.parse(displayText);
    } else if (displayText) {
      streamingMessageElement.textContent = displayText;
    }

    streamingMessageElement = null;
    streamingText = '';
    streamingStarted = false;

    return { text: displayText, displayText, signal };
  }

  function hideStreamingMessage() {
    if (streamingMessageElement) {
      streamingMessageElement.remove();
      streamingMessageElement = null;
      streamingText = '';
      streamingStarted = false;
    }
  }

  // Load chat history from localStorage
  let chatHistory = getChatHistory();

  // Render a message bubble
  function renderMessage(role, content) {
    const messageDiv = document.createElement('div');
    messageDiv.style.cssText = 'padding: 0.875rem 1rem 1rem 1rem; border-radius: 8px; max-width: 80%; word-wrap: break-word; line-height: 1.5;';

    if (role === 'assistant') {
      // Assistant message - translucent on purple bg
      messageDiv.style.cssText += 'background-color: rgba(255,255,255,0.12); color: rgba(255,255,255,0.9); align-self: flex-start; border-left: 3px solid #4c1d95; border-bottom-left-radius: 4px;';

      // Render markdown for assistant messages
      if (window.marked) {
        messageDiv.innerHTML = marked.parse(content);
      } else {
        messageDiv.textContent = content;
      }
    } else {
      // User message - darker purple, right-aligned
      messageDiv.style.cssText += 'background-color: #4c1d95; color: white; align-self: flex-end; border-bottom-right-radius: 4px;';
      messageDiv.textContent = content;
    }

    chatMessages.appendChild(messageDiv);
    chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
  }

  // Reply mode: fetch moment details for context banner
  if (replyToMomentId) {
    try {
      const res = await fetch(`/api/moment-list?limit=100`);
      const data = await res.json();
      if (data.success && data.moments) {
        replyMoment = data.moments.find(m => m.id === replyToMomentId);
      }
    } catch (e) { /* proceed without moment details */ }

    // In reply mode, always start fresh
    clearChatHistory();
    chatHistory = [];
  }

  // Add header to chat messages area
  const headerDiv = document.createElement('div');
  headerDiv.style.cssText = 'text-align: center; padding: 2rem 1rem 1rem 1rem; margin-bottom: 1rem;';

  if (replyMoment) {
    // Reply mode: context banner
    const momentDate = new Date(replyMoment.occurredAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const badgeClass = `moment-badge-${replyMoment.type || 'happy'}`;
    headerDiv.innerHTML = `
      <div style="font-size: 3rem; margin-bottom: .5rem;">üêΩ</div>
      <h1 style="margin: 0 0 0.75rem 0; font-size: 1.5rem; color: white; font-weight: 600;">Replying to ${replyMoment.addedBy || 'partner'}</h1>
      <div style="background: rgba(255,255,255,0.1); border-radius: 10px; padding: 1rem 1.25rem; text-align: left; margin: 0 auto; max-width: 500px;">
        <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.4rem;">
          <span class="moment-badge ${badgeClass}">${replyMoment.type || 'happy'}</span>
          <span style="color: rgba(255,255,255,0.5); font-size: 0.8rem;">${replyMoment.addedBy || ''}</span>
          <span style="color: rgba(255,255,255,0.35); font-size: 0.8rem; margin-left: auto;">${momentDate}</span>
        </div>
        <p style="margin: 0; color: rgba(255,255,255,0.85); font-size: 0.95rem; line-height: 1.5;">${replyMoment.content}</p>
      </div>
      <a href="/" style="display: inline-block; margin-top: 0.75rem; color: rgba(255,255,255,0.5); font-size: 0.85rem; text-decoration: none;">Cancel</a>
    `;
  } else {
    // Normal mode: standard header
    headerDiv.innerHTML = `
      <div style="font-size: 3rem; margin-bottom: .5rem;">üêΩ</div>
      <h1 style="margin: 0 0 0.5rem 0; font-size: 2rem; color: white; font-weight: 600;">Chat</h1>
      <p style="margin: 0; font-size: 0.95rem; color: rgba(255,255,255,0.6);">Get support from one who knows.<br/>Your chats stay 100% private.</p>
    `;
  }
  chatMessages.appendChild(headerDiv);

  // Check for pending survey (skip in reply mode)
  let hasSurvey = false;
  if (!replyToMomentId) {
    try {
      const res = await fetch(`/api/survey-check?userId=${encodeURIComponent(userId)}`);
      if (res.ok) {
        const data = await res.json();
        hasSurvey = !!data.hasSurvey;
      }
    } catch (e) { /* proceed without survey info */ }

    const hasUserMessages = chatHistory.some(m => m.role === 'user');
    if (hasSurvey && chatHistory.length > 0 && !hasUserMessages) {
      clearChatHistory();
      chatHistory = [];
    }
  }

  // Initialize chat with opening message or load history
  if (chatHistory.length === 0) {
    const hour = new Date().getHours();
    const timeGreeting = hour < 4 ? 'Happy late night' : hour < 12 ? 'Good morning' : hour < 13 ? 'Happy midday' : hour < 17 ? 'Good afternoon' : hour < 21 ? 'Good evening' : 'Happy late night';
    const name = userName || 'friend';

    let greeting;
    if (replyMoment) {
      const sharerName = replyMoment.addedBy || 'your partner';
      const sharerPronoun = { 'Erik': 'he', 'Marta': 'she' }[sharerName] || 'they';
      greeting = `${timeGreeting}, ${name}. I see ${sharerName} shared something. What stands out to you about what ${sharerPronoun} wrote?`;
    } else if (hasSurvey) {
      greeting = `${timeGreeting}, ${name}. There's a weekly mini-survey assigned to you. Ready to take it now?`;
    } else {
      greeting = `${timeGreeting}, ${name}. What's in your heart or mind today?`;
    }

    chatHistory.push({ role: 'assistant', content: greeting, timestamp: new Date().toISOString() });
    saveChatHistory(chatHistory);
  }

  // Render all messages from history
  chatHistory.forEach(msg => {
    renderMessage(msg.role, msg.content);
  });

  // Handle signals ‚Äî show appropriate confirmation popup
  function handleSignal(signal) {
    if (!signal) return;

    if (signal.type === 'SEND_REPLY') {
      return handleReplySignal(signal);
    }
    if (signal.type === 'STORE_MEASUREMENT') {
      return handleSurveySignal(signal);
    }
    if (signal.type !== 'SAVE_MOMENT') return;

    pendingSignal = signal;

    // Show moment summary in modal
    const data = signal.data || {};
    const summary = data.content || 'A moment from your conversation.';
    captureModalSummary.textContent = summary;

    // Show modal, disable chat
    captureModal.style.display = 'flex';
    messageInput.disabled = true;
    sendButton.disabled = true;
    sendButton.style.background = 'rgba(255,255,255,0.2)';
    sendButton.style.cursor = 'not-allowed';
  }

  // Handle STORE_MEASUREMENT signal ‚Äî show survey results modal
  function handleSurveySignal(signal) {
    pendingSignal = signal;
    const data = signal.data || {};
    const dimensions = data.dimensions || [];

    // Build scores display
    let scoresHtml = '';
    for (const dim of dimensions) {
      const pct = Math.round((dim.score / 10) * 100);
      scoresHtml += `
        <div style="margin-bottom: 0.75rem;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 0.25rem;">
            <span style="font-size: 0.9rem; color: #333; font-weight: 500;">${dim.name}</span>
            <span style="font-size: 0.9rem; color: #7c3aed; font-weight: 600;">${pct}%</span>
          </div>
          <div style="height: 6px; background: #f0e6ff; border-radius: 3px; overflow: hidden;">
            <div style="height: 100%; width: ${pct}%; background: #7c3aed; border-radius: 3px;"></div>
          </div>
          ${dim.notes ? `<div style="font-size: 0.8rem; color: #888; margin-top: 0.25rem; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">${dim.notes}</div>` : ''}
        </div>
      `;
    }

    surveyModalScores.innerHTML = scoresHtml;

    // Show modal, disable chat
    surveyModal.style.display = 'flex';
    messageInput.disabled = true;
    sendButton.disabled = true;
    sendButton.style.background = 'rgba(255,255,255,0.2)';
    sendButton.style.cursor = 'not-allowed';
  }

  // Handle SEND_REPLY signal ‚Äî save reply and navigate back
  async function handleReplySignal(signal) {
    const data = signal.data || {};
    const momentId = data.momentId || replyToMomentId;
    const content = data.content;

    if (!momentId || !content) {
      showToast('Reply could not be saved.', { type: 'error' });
      return;
    }

    try {
      const response = await fetch('/api/moment-reply-save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          momentId,
          content,
          repliedBy: userName
        })
      });

      const result = await response.json();
      if (result.success) {
        // Clear reply-mode chat history
        clearChatHistory();
        showToast('Reply sent!');
        setTimeout(() => { window.location.href = '/'; }, 1200);
      } else {
        showToast('Failed to save reply.', { type: 'error' });
      }
    } catch (error) {
      console.error('Error saving reply:', error);
      showToast('Failed to save reply.', { type: 'error' });
    }
  }

  // Save chat and get chatId (for linking moment back to conversation)
  async function ensureChatSaved() {
    const lastSavedIndex = getLastSavedIndex();
    const newMessages = chatHistory.slice(lastSavedIndex);
    if (newMessages.length === 0 && getChatId()) return getChatId();

    const existingChatId = getChatId();
    const isAppend = existingChatId && lastSavedIndex > 0;

    try {
      const response = await fetch('/api/relational-chat-save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId,
          messages: isAppend ? newMessages : chatHistory,
          chatId: existingChatId,
          mode: isAppend ? 'append' : 'create'
        })
      });

      const data = await response.json();
      if (data.success) {
        if (!existingChatId && data.chatId) {
          saveChatId(data.chatId);
        }
        saveLastSavedIndex(chatHistory.length);
        return getChatId();
      }
    } catch (error) {
      console.error('Error saving chat:', error);
    }
    return getChatId();
  }

  // Capture confirm button ‚Äî save chat then redirect to capture page
  captureConfirmBtn.addEventListener('click', async () => {
    captureModal.style.display = 'none';
    if (!pendingSignal) return;

    const signalData = pendingSignal.data || {};
    const chatId = await ensureChatSaved();

    // Build capture URL with pre-filled data
    const params = new URLSearchParams();
    if (signalData.type) params.set('type', signalData.type);
    if (signalData.content) params.set('content', signalData.content);
    if (chatId) params.set('chatId', chatId);

    pendingSignal = null;
    window.location.href = `/capture/?${params.toString()}`;
  });

  // Capture dismiss button
  captureDismissBtn.addEventListener('click', () => {
    captureModal.style.display = 'none';
    pendingSignal = null;
    messageInput.disabled = false;
    messageInput.focus();
    updateSendButton();
  });

  // Survey confirm button ‚Äî save check-in results
  surveyConfirmBtn.addEventListener('click', async () => {
    if (!pendingSignal) return;

    surveyConfirmBtn.textContent = 'Saving...';
    surveyConfirmBtn.disabled = true;

    try {
      const response = await fetch('/api/survey-measurement-save', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, signal: pendingSignal })
      });

      const data = await response.json();
      if (data.success) {
        // Transition modal to completion state
        const partners = { 'Erik': 'Marta', 'Marta': 'Erik' };
        const partnerName = partners[userName] || 'your partner';
        const modalInner = surveyModal.querySelector('div');
        modalInner.innerHTML = `
          <div style="font-size: 3.5rem;">ü¶•</div>
          <h3 style="margin: 0; font-size: 1.25rem; color: #1e0a3c;">Check-in saved!</h3>
          <p style="margin: 0 0 1.5rem 0; font-size: 0.9rem; color: #666; line-height: 1.4;">We'll check in with you again next week.</p>
          <button
            id="survey-done-btn"
            style="padding: 0.75rem 2rem; background: #7c3aed; color: white; border: none; border-radius: 24px; font-size: 1rem; font-weight: 600; cursor: pointer; transition: all 0.2s; box-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);"
          >Done</button>
          <button
            id="survey-new-chat-btn"
            style="display: block; margin: 1.25rem auto 0; padding: 0.5rem 1rem; background: transparent; color: #999; border: none; font-size: 0.9rem; cursor: pointer; text-decoration: underline;"
          >Start new chat</button>
        `;
        document.getElementById('survey-done-btn').addEventListener('click', () => {
          clearChatHistory();
          window.location.href = '/';
        });
        document.getElementById('survey-new-chat-btn').addEventListener('click', () => {
          clearChatHistory();
          window.location.reload();
        });
      } else {
        showToast('Failed to save check-in.', { type: 'error' });
        surveyModal.style.display = 'none';
        surveyConfirmBtn.textContent = 'Save';
        surveyConfirmBtn.disabled = false;
      }
    } catch (error) {
      console.error('Error saving survey:', error);
      showToast('Failed to save check-in.', { type: 'error' });
      surveyModal.style.display = 'none';
      surveyConfirmBtn.textContent = 'Save';
      surveyConfirmBtn.disabled = false;
    }

    pendingSignal = null;
  });

  // Survey dismiss button
  surveyDismissBtn.addEventListener('click', () => {
    surveyModal.style.display = 'none';
    pendingSignal = null;
    messageInput.disabled = false;
    messageInput.focus();
    updateSendButton();
  });

  // Streaming chat handler
  async function handleStreamingChat(message) {
    showStreamingMessage();

    const userTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;

    const response = await fetch('/api/chat-stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chatType: 'rely',
        userId,
        userName,
        message,
        timezone: userTimezone,
        replyToMomentId: replyToMomentId || undefined,
        chatHistory: chatHistory.slice(0, -1).map(msg => ({
          role: msg.role,
          content: msg.content
        }))
      })
    });

    if (!response.ok) {
      throw new Error(`Stream request failed: ${response.status}`);
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let receivedSignal = null;

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });

      // Parse SSE lines from buffer
      const lines = buffer.split('\n\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6));

            if (data.type === 'token') {
              appendStreamingText(data.text);
            } else if (data.type === 'done') {
              // Check for signal
              if (data.hasSignal && data.signal) {
                receivedSignal = data.signal;
              }
            } else if (data.type === 'error') {
              throw new Error(data.error);
            }
          } catch (parseErr) {
            console.warn('Failed to parse SSE data:', parseErr);
          }
        }
      }
    }

    // Finalize the streaming message
    const { text: fullResponse } = finalizeStreamingMessage(receivedSignal);

    // Add to chat history
    const assistantMessage = {
      role: 'assistant',
      content: fullResponse,
      timestamp: new Date().toISOString()
    };
    chatHistory.push(assistantMessage);
    saveChatHistory(chatHistory);

    // Handle signal if present
    if (receivedSignal) {
      await handleSignal(receivedSignal);
    }
  }

  // Handle form submission
  chatForm.addEventListener('submit', async (e) => {
    e.preventDefault();

    const message = messageInput.value.trim();
    if (!message) return;

    // Add user message to UI and history
    const userMessage = {
      role: 'user',
      content: message,
      timestamp: new Date().toISOString()
    };
    renderMessage('user', message);
    chatHistory.push(userMessage);
    saveChatHistory(chatHistory);

    // Clear input
    messageInput.value = '';
    messageInput.style.height = 'auto';

    // Disable send button
    sendButton.disabled = true;
    sendButton.style.background = 'rgba(255,255,255,0.2)';
    sendButton.style.color = 'rgba(255,255,255,0.4)';
    sendButton.style.cursor = 'not-allowed';

    // Handle streaming chat
    try {
      await handleStreamingChat(message);
    } catch (error) {
      console.error('Error sending message:', error);
      hideStreamingMessage();

      // Show error message
      const errorMessage = {
        role: 'assistant',
        content: "I'm having trouble connecting right now. Could you try again?",
        timestamp: new Date().toISOString()
      };
      renderMessage('assistant', errorMessage.content);
      chatHistory.push(errorMessage);
      saveChatHistory(chatHistory);
    }
  });

  // Handle Enter key - auto-submit on desktop only, newline on mobile
  messageInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter' && !e.shiftKey) {
      const isMobile = window.matchMedia('(pointer: coarse)').matches;
      if (!isMobile) {
        e.preventDefault();
        chatForm.requestSubmit();
      }
    }
  });

  // Auto-resize textarea and toggle send button
  messageInput.addEventListener('input', function() {
    this.style.height = 'auto';
    this.style.height = (this.scrollHeight) + 'px';
    updateSendButton();
  });

  // Handle save chat button
  document.getElementById('save-chat-btn').addEventListener('click', async () => {
    if (chatHistory.length === 0) {
      showToast('No conversation to save.', { type: 'info' });
      return;
    }

    const saveBtn = document.getElementById('save-chat-btn');
    const originalText = saveBtn.innerHTML;

    // Determine which messages are new (not yet saved)
    const lastSavedIndex = getLastSavedIndex();
    const newMessages = chatHistory.slice(lastSavedIndex);

    if (newMessages.length === 0) {
      showToast('Already saved.', { type: 'info' });
      return;
    }

    const existingChatId = getChatId();
    const isAppend = existingChatId && lastSavedIndex > 0;

    try {
      // Show loading state
      saveBtn.textContent = 'Saving...';
      saveBtn.disabled = true;

      // Save relational chat to backend (only new messages for append)
      const response = await fetch('/api/relational-chat-save', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          userId,
          messages: isAppend ? newMessages : chatHistory,
          chatId: existingChatId,
          mode: isAppend ? 'append' : 'create'
        })
      });

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.error || 'Failed to save chat');
      }

      // Track the chat ID for future appends
      if (!existingChatId && data.chatId) {
        saveChatId(data.chatId);
      }

      // Update last saved index to current length
      saveLastSavedIndex(chatHistory.length);

      // Restore button and show success
      saveBtn.innerHTML = originalText;
      saveBtn.disabled = false;
      showToast('Saved!');

    } catch (error) {
      console.error('Error saving relational chat:', error);
      showToast('Failed to save. Please try again.', { type: 'error' });

      // Restore button state
      saveBtn.innerHTML = originalText;
      saveBtn.disabled = false;
    }
  });

  // Handle reset chat button
  document.getElementById('reset-chat-btn').addEventListener('click', () => {
    if (confirm('Start a fresh conversation? This will clear your current chat.')) {
      clearChatHistory();
      if (replyToMomentId) {
        window.location.href = '/chat/';
      } else {
        window.location.reload();
      }
    }
  });

  // Handle history button
  document.getElementById('history-chat-btn').addEventListener('click', async () => {
    const historyBtn = document.getElementById('history-chat-btn');
    const originalText = historyBtn.textContent;

    try {
      historyBtn.textContent = 'Loading...';
      historyBtn.disabled = true;

      // Fetch saved relational chats
      const response = await fetch(`/api/relational-chat-list?userId=${encodeURIComponent(userId)}&limit=10`);
      const data = await response.json();

      if (!data.success || !data.relationalChats || data.relationalChats.length === 0) {
        showToast('No saved conversations yet.', { type: 'info' });
        historyBtn.textContent = originalText;
        historyBtn.disabled = false;
        return;
      }

      // Show history modal
      showHistoryModal(data.relationalChats);

      historyBtn.textContent = originalText;
      historyBtn.disabled = false;

    } catch (error) {
      console.error('Error loading history:', error);
      showToast('Failed to load history.', { type: 'error' });
      historyBtn.textContent = originalText;
      historyBtn.disabled = false;
    }
  });

  // History modal
  function showHistoryModal(chats) {
    // Remove existing modal if any
    const existingModal = document.getElementById('history-modal');
    if (existingModal) existingModal.remove();

    const modal = document.createElement('div');
    modal.id = 'history-modal';
    modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; align-items: center; justify-content: center;';

    const content = document.createElement('div');
    content.style.cssText = 'background: white; border-radius: 12px; padding: 1.5rem; max-width: 400px; width: 90%; max-height: 80vh; overflow-y: auto;';

    const header = document.createElement('div');
    header.style.cssText = 'display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;';
    header.innerHTML = `
      <h3 style="margin: 0; font-size: 1.1rem; color: #333;">Saved Conversations</h3>
      <button id="close-history" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: #999;">&times;</button>
    `;
    content.appendChild(header);

    const list = document.createElement('div');
    list.style.cssText = 'display: flex; flex-direction: column; gap: 0.75rem;';

    chats.forEach(chat => {
      const item = document.createElement('div');
      item.style.cssText = 'padding: 0.75rem; border: 1px solid #eee; border-radius: 8px; cursor: pointer; transition: background 0.2s;';
      item.onmouseover = () => item.style.background = '#faf5ff';
      item.onmouseout = () => item.style.background = 'white';

      // Get preview from first user message or assistant message
      const firstUserMsg = chat.messages?.find(m => m.role === 'user');
      const preview = firstUserMsg?.content?.substring(0, 60) || 'Conversation';
      const date = new Date(chat.savedAt).toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit'
      });

      item.innerHTML = `
        <div style="font-size: 0.9rem; color: #333; margin-bottom: 0.25rem;">${preview}${preview.length >= 60 ? '...' : ''}</div>
        <div style="font-size: 0.75rem; color: #999;">${date} - ${chat.messages?.length || 0} messages</div>
      `;

      item.addEventListener('click', () => {
        loadSavedChat(chat);
        modal.remove();
      });

      list.appendChild(item);
    });

    content.appendChild(list);
    modal.appendChild(content);
    document.body.appendChild(modal);

    // Close on overlay click or close button
    modal.addEventListener('click', (e) => {
      if (e.target === modal) modal.remove();
    });
    document.getElementById('close-history').addEventListener('click', () => modal.remove());
  }

  // Load a saved chat into the current view
  function loadSavedChat(chat) {
    // Clear current messages display (except header)
    while (chatMessages.children.length > 1) {
      chatMessages.removeChild(chatMessages.lastChild);
    }

    // Load messages from saved chat
    chatHistory = chat.messages || [];
    saveChatHistory(chatHistory);
    saveChatId(chat.id);
    saveLastSavedIndex(chatHistory.length);

    // Render all messages
    chatHistory.forEach(msg => {
      renderMessage(msg.role, msg.content);
    });

    showToast('Conversation loaded.');
  }

  // Focus message input on load
  messageInput.focus();

</script>
